<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>52、WebRTC音视频</title><meta name="description" content="呦呦鹿鸣，食野之苹"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="WebRTC (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC 包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。


一、WebRTC 音视频采集 API：MediaDevices.getUserMedia()
MediaDevices.getUserMedia() 会提示用户给予使用媒体输入的许可，媒体输入会产生一个 MediaStream，里面包含了请求的媒体类型的轨道。此流可以包含一个视频轨道（来自硬件或者虚拟视频源，比如.."><meta name="generator" content="Hexo 5.4.1"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Jude's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">52、WebRTC音视频</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81WebRTC-%E9%9F%B3%E8%A7%86%E9%A2%91%E9%87%87%E9%9B%86-API%EF%BC%9AMediaDevices-getUserMedia"><span class="toc-text">一、WebRTC 音视频采集 API：MediaDevices.getUserMedia()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%8E%B7%E5%8F%96%E9%9F%B3%E8%A7%86%E9%A2%91%E8%AE%BE%E5%A4%87%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%88%97%E8%A1%A8-MediaDevices-enumerateDevices"><span class="toc-text">二、获取音视频设备输入输出列表:MediaDevices.enumerateDevices()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%82%B9%E5%AF%B9%E7%82%B9%E5%AA%92%E4%BD%93%E5%8D%8F%E5%95%86%E6%96%B9%E6%B3%95"><span class="toc-text">三、点对点媒体协商方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%9AKoa-socket-io"><span class="toc-text">四、服务端：Koa + socket.io</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/webrtc"><i class="tag post-item-tag">webrtc</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">52、WebRTC音视频</h1><time class="has-text-grey" datetime="2022-01-19T02:05:56.000Z">2022-01-19</time><article class="mt-2 post-content"><p>WebRTC (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC 包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。</p>
<span id="more"></span>

<h3 id="一、WebRTC-音视频采集-API：MediaDevices-getUserMedia"><a href="#一、WebRTC-音视频采集-API：MediaDevices-getUserMedia" class="headerlink" title="一、WebRTC 音视频采集 API：MediaDevices.getUserMedia()"></a>一、WebRTC 音视频采集 API：MediaDevices.getUserMedia()</h3><blockquote>
<p>MediaDevices.getUserMedia() 会提示用户给予使用媒体输入的许可，媒体输入会产生一个 MediaStream，里面包含了请求的媒体类型的轨道。此流可以包含一个视频轨道（来自硬件或者虚拟视频源，比如相机、视频采集设备和屏幕共享服务等等）、一个音频轨道（同样来自硬件或虚拟音频源，比如麦克风、A/D 转换器等等），也可能是其它轨道类型。</p>
</blockquote>
<pre><code class="js">const constraints = &#123;
  video: true,
  audio: true,
&#125;;
//   非安全模式（非https/localhost）下 navigator.mediaDevices 会返回 undefined
try &#123;
  const stream = await navigator.mediaDevices.getUserMedia(constraints);
  document.querySelector(&quot;video&quot;).srcObject = stream;
&#125; catch (error) &#123;
  console.error(error);
&#125;
</code></pre>
<h3 id="二、获取音视频设备输入输出列表-MediaDevices-enumerateDevices"><a href="#二、获取音视频设备输入输出列表-MediaDevices-enumerateDevices" class="headerlink" title="二、获取音视频设备输入输出列表:MediaDevices.enumerateDevices()"></a>二、获取音视频设备输入输出列表:MediaDevices.enumerateDevices()</h3><blockquote>
<p>MediaDevices 的方法 enumerateDevices() 请求一个可用的媒体输入和输出设备的列表，例如麦克风，摄像机，耳机设备等。 返回的 Promise (en-US) 完成时，会带有一个描述设备的 MediaDeviceInfo (en-US) 的数组。</p>
</blockquote>
<pre><code class="js">try &#123;
  const devices = await navigator.mediaDevices.enumerateDevices();
  this.videoinputs = devices.filter((device) =&gt; device.kind === &quot;videoinput&quot;);
  this.audiooutputs = devices.filter((device) =&gt; device.kind === &quot;audiooutput&quot;);
  this.audioinputs = devices.filter((device) =&gt; device.kind === &quot;audioinput&quot;);
&#125; catch (error) &#123;
  console.error(error);
&#125;
</code></pre>
<h3 id="三、点对点媒体协商方法"><a href="#三、点对点媒体协商方法" class="headerlink" title="三、点对点媒体协商方法"></a>三、点对点媒体协商方法</h3><p>媒体协商方法：</p>
<p>1、createOffer：</p>
<blockquote>
<p>createOffer 方法会生成描述信息的一个 blob 对象，它会帮助连接到本地机器。当你已经找到一个远端的 PeerConnection 并且打算设置建立本地的 PeerConnection 时，你可以使用该方法。</p>
</blockquote>
<pre><code class="js">var pc = new PeerConnection();
pc.addStream(video);
pc.createOffer(function(desc)&#123;
  pc.setLocalDescription(desc, function() &#123;
    // send the offer to a server that can negotiate with a remote client
  &#125;);
&#125;
</code></pre>
<p>2、createAnswer：</p>
<blockquote>
<p>对从远方收到的 offer 进行回答。</p>
</blockquote>
<pre><code class="js">var pc = new PeerConnection();
pc.setRemoteDescription(new RTCSessionDescription(offer), function () &#123;
  pc.createAnswer(function (answer) &#123;
    pc.setLocalDescription(answer, function () &#123;
      // send the answer to the remote connection
    &#125;);
  &#125;);
&#125;);
</code></pre>
<h3 id="四、服务端：Koa-socket-io"><a href="#四、服务端：Koa-socket-io" class="headerlink" title="四、服务端：Koa + socket.io"></a>四、服务端：Koa + socket.io</h3><p>1、server.js</p>
<pre><code class="js">// server 端 server.js
const Koa = require(&quot;koa&quot;);
const socket = require(&quot;socket.io&quot;);
const http = require(&quot;http&quot;);
const app = new Koa();
const httpServer = http.createServer(app.callback()).listen(3000, () =&gt; &#123;&#125;);
socket(httpServer).on(&quot;connection&quot;, (sock) =&gt; &#123;
  // ....
&#125;);

// client 端 socket.js
import io from &quot;socket.io-client&quot;;
const socket = io.connect(window.location.origin);
export default socket;
</code></pre>
<p>2、点对点分别连接信令服务器，信令服务器记录房间信息</p>
<pre><code class="js">socket(httpServer).on(&quot;connection&quot;, (sock) =&gt; &#123;
  // 用户离开房间
  sock.on(&quot;userLeave&quot;, () =&gt; &#123;
    // ...
  &#125;);
  // 检查房间是否可加入
  sock.on(&quot;checkRoom&quot;, () =&gt; &#123;
    // ...
  &#125;);
  // ....
&#125;);
// client 端 Room.vue
import socket from &quot;../utils/socket.js&quot;;

// 服务端告知用户是否可加入房间
socket.on(&quot;checkRoomSuccess&quot;, () =&gt; &#123;
  // ...
&#125;);
// 服务端告知用户成功加入房间
socket.on(&quot;joinRoomSuccess&quot;, () =&gt; &#123;
  // ...
&#125;);
//....
</code></pre>
<p>3、A 端作为发起方向接收方 B 端发起视频邀请</p>
<p>在得到 B 同意视频请求后，双方都会创建本地的 RTCPeerConnection，添加本地视频流，其中发送方会创建 offer 设置本地 sdp 信息描述，并通过信令服务器将自己的 SDP 信息发送给对端</p>
<pre><code class="js">socket.on(&quot;answerVideo&quot;, async (user) =&gt; &#123;
  VIDEO_VIEW.showInvideoModal();
  // 创建本地视频流信息
  const localStream = await this.createLocalVideoStream();
  this.localStream = localStream;
  document.querySelector(&quot;#echat-local&quot;).srcObject = this.localStream;
  this.peer = new RTCPeerConnection();
  this.initPeerListen();
  this.peer.addStream(this.localStream);
  if (user.sockId === this.sockId) &#123;
    // 接收方
  &#125; else &#123;
    // 发送方 创建 offer
    const offer = await this.peer.createOffer(this.offerOption);
    await this.peer.setLocalDescription(offer);
    socket.emit(&quot;receiveOffer&quot;, &#123; user: this.user, offer &#125;);
  &#125;
&#125;);
</code></pre>
<p>4、收集自己的网络信息并发送给对方</p>
<pre><code class="js">initPeerListen () &#123;
      // 收集自己的网络信息并发送给对端
      this.peer.onicecandidate = (event) =&gt; &#123;
        if (event.candidate) &#123; socket.emit(&#39;addIceCandidate&#39;, &#123; candidate: event.candidate, user: this.user &#125;); &#125;
      &#125;;
      // ....
    &#125;
</code></pre>
<p>5、当接收方 B 端通过信令服务器拿到对端发送方 A 端的含有 SDP 的 offer 信息后则会调用 setRemoteDescription 存储对端的 SDP 信息，创建及设置本地的 SDP 信息,并通过信令服务器传送含有本地 SDP 信息的 answer</p>
<pre><code class="js">socket.on(&quot;receiveOffer&quot;, async (offer) =&gt; &#123;
  await this.peer.setRemoteDescription(offer);
  const answer = await this.peer.createAnswer();
  await this.peer.setLocalDescription(answer);
  socket.emit(&quot;receiveAnsewer&quot;, &#123; answer, user: this.user &#125;);
&#125;);
</code></pre>
<p>6、当发起方 A 通过信令服务器接收到接收方 B 的 answer 信息后则也会调用 setRemoteDescription，这样双方就完成了 SDP 信息的交换</p>
<pre><code class="js">socket.on(&quot;receiveAnsewer&quot;, (answer) =&gt; &#123;
  this.peer.setRemoteDescription(answer);
&#125;);
</code></pre>
<p>7、当双方 SDP 信息交换完成并且监听 icecandidate 收集到网络候选者通过信令服务器交换后，则会拿到彼此的视频流。</p>
<pre><code class="js">socket.on(&quot;addIceCandidate&quot;, async (candidate) =&gt; &#123;
  await this.peer.addIceCandidate(candidate);
&#125;);
this.peer.onaddstream = (event) =&gt; &#123;
  // 拿到对方的视频流
  document.querySelector(&quot;#remote-video&quot;).srcObject = event.stream;
&#125;;
</code></pre>
<p>8、GitHub：<a target="_blank" rel="noopener" href="https://github.com/HeyJudeYQ/webrtc">https://github.com/HeyJudeYQ/webrtc</a></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2022/01/20/decorator/" title="53、vue使用装饰器descriptor"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 53、vue使用装饰器descriptor</span></a><a class="button is-default" href="/2022/01/15/export-excel/" title="51、Vue项目中前端导出/导入Excel表格的实现"><span class="has-text-weight-semibold">下一页: 51、Vue项目中前端导出/导入Excel表格的实现</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Jude"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/https://www.zhihu.com/hot"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Jude 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span>记住昨日的美好，过好今日的生活，憧憬明天的到来</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>